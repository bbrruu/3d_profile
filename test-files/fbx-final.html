<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBXæ¸¬è©¦ - å·¥ä½œç‰ˆæœ¬</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        #viewer {
            width: 100%;
            height: 500px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
        }
        button {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 12px 24px;
            margin: 5px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        .status {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 15px;
            border-radius: 20px;
            margin: 10px 0;
            font-family: monospace;
        }
        .success { color: #4ade80; }
        .error { color: #f87171; }
        .warning { color: #fbbf24; }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <h1>ğŸ¯ FBXæ¨¡å‹è¼‰å…¥æ¸¬è©¦</h1>
            <p>å°ˆæ¥­ç‰ˆæœ¬çš„FBXè¼‰å…¥å™¨ï¼Œç¢ºä¿èˆ‡æ‚¨çš„æ¨¡å‹å…¼å®¹ã€‚</p>
            <div class="status" id="status">æº–å‚™ä¸­...</div>
        </div>

        <div class="card">
            <h3>ğŸ® æ§åˆ¶é¢æ¿</h3>
            <button onclick="loadFBX()">ğŸš€ è¼‰å…¥FBXæ¨¡å‹</button>
            <button onclick="createTestCube()">ğŸ“¦ æ¸¬è©¦ç«‹æ–¹é«”</button>
            <button onclick="resetCamera()">ğŸ”„ é‡ç½®è¦–è§’</button>
            <button onclick="toggleWireframe()">ğŸ”² ç·šæ¡†æ¨¡å¼</button>
            <button onclick="downloadModel()">ğŸ’¾ ä¸‹è¼‰æ¨¡å‹æ•¸æ“š</button>
        </div>

        <div id="viewer"></div>

        <div class="card">
            <h3>â„¹ï¸ æ¨¡å‹ä¿¡æ¯</h3>
            <div id="model-info">ç­‰å¾…è¼‰å…¥æ¨¡å‹...</div>
        </div>
    </div>

    <!-- ä½¿ç”¨CDNè¼‰å…¥Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/libs/fflate.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/loaders/FBXLoader.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let currentModel = null;
        let isWireframe = false;

        function updateStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : type === 'warning' ? 'warning' : '';
            statusEl.innerHTML = `<span class="${className}">${message}</span>`;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function updateModelInfo(info) {
            document.getElementById('model-info').innerHTML = info;
        }

        function init() {
            updateStatus('åˆå§‹åŒ–3Då¼•æ“...', 'info');
            
            const container = document.getElementById('viewer');
            
            // å ´æ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            
            // ç›¸æ©Ÿ
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(8, 6, 8);
            
            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(renderer.domElement);
            
            // æ§åˆ¶å™¨
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1;
            
            // ç’°å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            // ä¸»å…‰æº
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // è£œå…‰
            const light2 = new THREE.DirectionalLight(0x4488ff, 0.3);
            light2.position.set(-5, 3, -5);
            scene.add(light2);
            
            // åœ°æ¿
            const floorGeometry = new THREE.PlaneGeometry(20, 20);
            const floorMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x16213e,
                transparent: true,
                opacity: 0.8
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // ç¶²æ ¼
            const gridHelper = new THREE.GridHelper(20, 20, 0x4a5568, 0x2d3748);
            scene.add(gridHelper);
            
            // æ¸²æŸ“å¾ªç’°
            animate();
            
            updateStatus('âœ… 3Då¼•æ“åˆå§‹åŒ–å®Œæˆ', 'success');
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function loadFBX() {
            updateStatus('ğŸ”„ é–‹å§‹è¼‰å…¥FBXæ¨¡å‹...', 'info');
            
            // ç­‰å¾…æ‰€æœ‰è…³æœ¬è¼‰å…¥å®Œæˆ
            if (typeof THREE === 'undefined') {
                updateStatus('âŒ Three.jsæœªè¼‰å…¥', 'error');
                return;
            }
            
            if (typeof THREE.FBXLoader === 'undefined') {
                updateStatus('âŒ FBXLoaderæœªè¼‰å…¥ï¼Œæ­£åœ¨å˜—è©¦é‡æ–°è¼‰å…¥...', 'warning');
                // å˜—è©¦å‹•æ…‹è¼‰å…¥FBXLoader
                const script = document.createElement('script');
                script.src = 'https://threejs.org/examples/js/loaders/FBXLoader.js';
                script.onload = () => {
                    setTimeout(() => loadFBX(), 500); // å»¶é²é‡è©¦
                };
                script.onerror = () => {
                    updateStatus('âŒ ç„¡æ³•è¼‰å…¥FBXLoader', 'error');
                };
                document.head.appendChild(script);
                return;
            }
            
            const loader = new THREE.FBXLoader();
            
            loader.load(
                'models/fuck.fbx',
                function(object) {
                    updateStatus('âœ… FBXæ¨¡å‹è¼‰å…¥æˆåŠŸï¼', 'success');
                    
                    // ç§»é™¤èˆŠæ¨¡å‹
                    if (currentModel) {
                        scene.remove(currentModel);
                    }
                    
                    currentModel = object;
                    
                    // åˆ†ææ¨¡å‹
                    const box = new THREE.Box3().setFromObject(currentModel);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    
                    // çµ±è¨ˆä¿¡æ¯
                    let meshCount = 0;
                    let vertexCount = 0;
                    let materialCount = 0;
                    
                    currentModel.traverse(function(child) {
                        if (child.isMesh) {
                            meshCount++;
                            if (child.geometry) {
                                if (child.geometry.attributes.position) {
                                    vertexCount += child.geometry.attributes.position.count;
                                }
                            }
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            // æª¢æŸ¥å’Œä¿®å¾©æè³ª
                            if (!child.material) {
                                // å¦‚æœæ²’æœ‰æè³ªï¼Œæ·»åŠ é»˜èªæè³ª
                                child.material = new THREE.MeshLambertMaterial({
                                    color: 0x4a90e2, // è—è‰²
                                    transparent: false
                                });
                                debugLog(`ç‚ºç¶²æ ¼æ·»åŠ é»˜èªæè³ª: ${child.name || 'unnamed'}`);
                            } else {
                                // æª¢æŸ¥æè³ªé¡å‹ä¸¦ç¢ºä¿æ”¯æ´å…‰ç…§
                                if (child.material.type === 'MeshBasicMaterial') {
                                    // å°‡BasicMaterialè½‰æ›ç‚ºLambertä»¥æ”¯æ´å…‰ç…§
                                    const oldColor = child.material.color ? child.material.color.clone() : new THREE.Color(0x888888);
                                    child.material = new THREE.MeshLambertMaterial({
                                        color: oldColor,
                                        transparent: child.material.transparent || false,
                                        opacity: child.material.opacity || 1.0
                                    });
                                    debugLog(`æè³ªå·²è½‰æ›ç‚ºLambert: ${child.name || 'unnamed'}`);
                                } else if (child.material.color) {
                                    // å¦‚æœæ˜¯é»‘è‰²æˆ–å¤ªæš—ï¼Œèª¿äº®ä¸€äº›
                                    const color = child.material.color;
                                    if (color.r < 0.1 && color.g < 0.1 && color.b < 0.1) {
                                        color.setHex(0x7289da); // è¨­ç‚ºè¼ƒäº®çš„è—ç°è‰²
                                        debugLog(`èª¿æ•´éæš—çš„æè³ªé¡è‰²: ${child.name || 'unnamed'}`);
                                    }
                                }
                            }
                            
                            debugLog(`ç¶²æ ¼: ${child.name || 'unnamed'}, æè³ª: ${child.material.type}, é¡è‰²: #${child.material.color.getHexString()}`);
                        }
                        if (child.material) {
                            materialCount++;
                        }
                    });
                    
                    // æ›´æ–°ä¿¡æ¯é¡¯ç¤º
                    const info = `
                        <strong>ğŸ“Š æ¨¡å‹çµ±è¨ˆ:</strong><br>
                        â€¢ å°ºå¯¸: ${size.x.toFixed(2)} Ã— ${size.y.toFixed(2)} Ã— ${size.z.toFixed(2)}<br>
                        â€¢ ç¶²æ ¼æ•¸é‡: ${meshCount}<br>
                        â€¢ é ‚é»æ•¸é‡: ${vertexCount.toLocaleString()}<br>
                        â€¢ æè³ªæ•¸é‡: ${materialCount}<br>
                        â€¢ æ–‡ä»¶å¤§å°: ${(366928 / 1024).toFixed(1)} KB
                    `;
                    updateModelInfo(info);
                    
                    // ç¸®æ”¾å’Œå®šä½
                    const maxDim = Math.max(size.x, size.y, size.z);
                    if (maxDim > 0) {
                        const scale = 5 / maxDim;
                        currentModel.scale.setScalar(scale);
                        currentModel.position.copy(center).multiplyScalar(-scale);
                        currentModel.position.y = 0; // ç¢ºä¿æ¨¡å‹åœ¨åœ°é¢ä¸Š
                    }
                    
                    scene.add(currentModel);
                    
                    // èª¿æ•´ç›¸æ©Ÿè¦–è§’
                    const distance = Math.max(5, maxDim * 1.5);
                    camera.position.set(distance, distance * 0.7, distance);
                    camera.lookAt(0, 0, 0);
                    
                    updateStatus(`ğŸ¯ æ¨¡å‹å·²è¼‰å…¥ (${meshCount}å€‹ç¶²æ ¼)`, 'success');
                },
                function(progress) {
                    if (progress.total > 0) {
                        const percent = Math.round((progress.loaded / progress.total) * 100);
                        updateStatus(`â³ è¼‰å…¥é€²åº¦: ${percent}%`, 'info');
                    }
                },
                function(error) {
                    console.error('FBXè¼‰å…¥éŒ¯èª¤:', error);
                    updateStatus(`âŒ è¼‰å…¥å¤±æ•—: ${error.message || error}`, 'error');
                }
            );
        }

        function createTestCube() {
            updateStatus('ğŸ”¨ å‰µå»ºæ¸¬è©¦ç«‹æ–¹é«”...', 'info');
            
            if (currentModel) {
                scene.remove(currentModel);
            }
            
            const geometry = new THREE.BoxGeometry(3, 3, 3);
            const material = new THREE.MeshLambertMaterial({ 
                color: 0x00ff88,
                transparent: true,
                opacity: 0.8
            });
            
            currentModel = new THREE.Mesh(geometry, material);
            currentModel.position.set(0, 1.5, 0);
            currentModel.castShadow = true;
            currentModel.receiveShadow = true;
            
            scene.add(currentModel);
            
            updateModelInfo('âœ… æ¸¬è©¦ç«‹æ–¹é«” - ç¢ºèª3Då¼•æ“æ­£å¸¸å·¥ä½œ');
            updateStatus('âœ… æ¸¬è©¦ç«‹æ–¹é«”å·²å‰µå»º', 'success');
        }

        function resetCamera() {
            camera.position.set(8, 6, 8);
            camera.lookAt(0, 0, 0);
            controls.reset();
            updateStatus('ğŸ”„ è¦–è§’å·²é‡ç½®', 'info');
        }

        function toggleWireframe() {
            isWireframe = !isWireframe;
            
            if (currentModel) {
                currentModel.traverse(function(child) {
                    if (child.isMesh && child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => mat.wireframe = isWireframe);
                        } else {
                            child.material.wireframe = isWireframe;
                        }
                    }
                });
                
                updateStatus(isWireframe ? 'ğŸ“ ç·šæ¡†æ¨¡å¼é–‹å•Ÿ' : 'ğŸ¨ å¯¦é«”æ¨¡å¼é–‹å•Ÿ', 'info');
            }
        }

        function downloadModel() {
            if (!currentModel) {
                updateStatus('âŒ æ²’æœ‰å¯ä¸‹è¼‰çš„æ¨¡å‹', 'error');
                return;
            }
            
            // å°å‡ºæ¨¡å‹ä¿¡æ¯ç‚ºJSON
            const modelData = {
                name: 'fuck.fbx',
                timestamp: new Date().toISOString(),
                boundingBox: {
                    min: new THREE.Box3().setFromObject(currentModel).min,
                    max: new THREE.Box3().setFromObject(currentModel).max,
                    size: new THREE.Box3().setFromObject(currentModel).getSize(new THREE.Vector3())
                },
                position: currentModel.position,
                rotation: currentModel.rotation,
                scale: currentModel.scale
            };
            
            const dataStr = JSON.stringify(modelData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = 'model-info.json';
            link.click();
            
            updateStatus('ğŸ’¾ æ¨¡å‹æ•¸æ“šå·²ä¸‹è¼‰', 'success');
        }

        // éŸ¿æ‡‰å¼è™•ç†
        window.addEventListener('resize', function() {
            const container = document.getElementById('viewer');
            if (container.clientWidth > 0) {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
        });

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
