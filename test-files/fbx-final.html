<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBX測試 - 工作版本</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        #viewer {
            width: 100%;
            height: 500px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
        }
        button {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 12px 24px;
            margin: 5px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        .status {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 15px;
            border-radius: 20px;
            margin: 10px 0;
            font-family: monospace;
        }
        .success { color: #4ade80; }
        .error { color: #f87171; }
        .warning { color: #fbbf24; }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <h1>🎯 FBX模型載入測試</h1>
            <p>專業版本的FBX載入器，確保與您的模型兼容。</p>
            <div class="status" id="status">準備中...</div>
        </div>

        <div class="card">
            <h3>🎮 控制面板</h3>
            <button onclick="loadFBX()">🚀 載入FBX模型</button>
            <button onclick="createTestCube()">📦 測試立方體</button>
            <button onclick="resetCamera()">🔄 重置視角</button>
            <button onclick="toggleWireframe()">🔲 線框模式</button>
            <button onclick="downloadModel()">💾 下載模型數據</button>
        </div>

        <div id="viewer"></div>

        <div class="card">
            <h3>ℹ️ 模型信息</h3>
            <div id="model-info">等待載入模型...</div>
        </div>
    </div>

    <!-- 使用CDN載入Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/libs/fflate.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/loaders/FBXLoader.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let currentModel = null;
        let isWireframe = false;

        function updateStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : type === 'warning' ? 'warning' : '';
            statusEl.innerHTML = `<span class="${className}">${message}</span>`;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function updateModelInfo(info) {
            document.getElementById('model-info').innerHTML = info;
        }

        function init() {
            updateStatus('初始化3D引擎...', 'info');
            
            const container = document.getElementById('viewer');
            
            // 場景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            
            // 相機
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(8, 6, 8);
            
            // 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(renderer.domElement);
            
            // 控制器
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1;
            
            // 環境光
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            // 主光源
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // 補光
            const light2 = new THREE.DirectionalLight(0x4488ff, 0.3);
            light2.position.set(-5, 3, -5);
            scene.add(light2);
            
            // 地板
            const floorGeometry = new THREE.PlaneGeometry(20, 20);
            const floorMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x16213e,
                transparent: true,
                opacity: 0.8
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // 網格
            const gridHelper = new THREE.GridHelper(20, 20, 0x4a5568, 0x2d3748);
            scene.add(gridHelper);
            
            // 渲染循環
            animate();
            
            updateStatus('✅ 3D引擎初始化完成', 'success');
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function loadFBX() {
            updateStatus('🔄 開始載入FBX模型...', 'info');
            
            // 等待所有腳本載入完成
            if (typeof THREE === 'undefined') {
                updateStatus('❌ Three.js未載入', 'error');
                return;
            }
            
            if (typeof THREE.FBXLoader === 'undefined') {
                updateStatus('❌ FBXLoader未載入，正在嘗試重新載入...', 'warning');
                // 嘗試動態載入FBXLoader
                const script = document.createElement('script');
                script.src = 'https://threejs.org/examples/js/loaders/FBXLoader.js';
                script.onload = () => {
                    setTimeout(() => loadFBX(), 500); // 延遲重試
                };
                script.onerror = () => {
                    updateStatus('❌ 無法載入FBXLoader', 'error');
                };
                document.head.appendChild(script);
                return;
            }
            
            const loader = new THREE.FBXLoader();
            
            loader.load(
                'models/fuck.fbx',
                function(object) {
                    updateStatus('✅ FBX模型載入成功！', 'success');
                    
                    // 移除舊模型
                    if (currentModel) {
                        scene.remove(currentModel);
                    }
                    
                    currentModel = object;
                    
                    // 分析模型
                    const box = new THREE.Box3().setFromObject(currentModel);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    
                    // 統計信息
                    let meshCount = 0;
                    let vertexCount = 0;
                    let materialCount = 0;
                    
                    currentModel.traverse(function(child) {
                        if (child.isMesh) {
                            meshCount++;
                            if (child.geometry) {
                                if (child.geometry.attributes.position) {
                                    vertexCount += child.geometry.attributes.position.count;
                                }
                            }
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            // 檢查和修復材質
                            if (!child.material) {
                                // 如果沒有材質，添加默認材質
                                child.material = new THREE.MeshLambertMaterial({
                                    color: 0x4a90e2, // 藍色
                                    transparent: false
                                });
                                debugLog(`為網格添加默認材質: ${child.name || 'unnamed'}`);
                            } else {
                                // 檢查材質類型並確保支援光照
                                if (child.material.type === 'MeshBasicMaterial') {
                                    // 將BasicMaterial轉換為Lambert以支援光照
                                    const oldColor = child.material.color ? child.material.color.clone() : new THREE.Color(0x888888);
                                    child.material = new THREE.MeshLambertMaterial({
                                        color: oldColor,
                                        transparent: child.material.transparent || false,
                                        opacity: child.material.opacity || 1.0
                                    });
                                    debugLog(`材質已轉換為Lambert: ${child.name || 'unnamed'}`);
                                } else if (child.material.color) {
                                    // 如果是黑色或太暗，調亮一些
                                    const color = child.material.color;
                                    if (color.r < 0.1 && color.g < 0.1 && color.b < 0.1) {
                                        color.setHex(0x7289da); // 設為較亮的藍灰色
                                        debugLog(`調整過暗的材質顏色: ${child.name || 'unnamed'}`);
                                    }
                                }
                            }
                            
                            debugLog(`網格: ${child.name || 'unnamed'}, 材質: ${child.material.type}, 顏色: #${child.material.color.getHexString()}`);
                        }
                        if (child.material) {
                            materialCount++;
                        }
                    });
                    
                    // 更新信息顯示
                    const info = `
                        <strong>📊 模型統計:</strong><br>
                        • 尺寸: ${size.x.toFixed(2)} × ${size.y.toFixed(2)} × ${size.z.toFixed(2)}<br>
                        • 網格數量: ${meshCount}<br>
                        • 頂點數量: ${vertexCount.toLocaleString()}<br>
                        • 材質數量: ${materialCount}<br>
                        • 文件大小: ${(366928 / 1024).toFixed(1)} KB
                    `;
                    updateModelInfo(info);
                    
                    // 縮放和定位
                    const maxDim = Math.max(size.x, size.y, size.z);
                    if (maxDim > 0) {
                        const scale = 5 / maxDim;
                        currentModel.scale.setScalar(scale);
                        currentModel.position.copy(center).multiplyScalar(-scale);
                        currentModel.position.y = 0; // 確保模型在地面上
                    }
                    
                    scene.add(currentModel);
                    
                    // 調整相機視角
                    const distance = Math.max(5, maxDim * 1.5);
                    camera.position.set(distance, distance * 0.7, distance);
                    camera.lookAt(0, 0, 0);
                    
                    updateStatus(`🎯 模型已載入 (${meshCount}個網格)`, 'success');
                },
                function(progress) {
                    if (progress.total > 0) {
                        const percent = Math.round((progress.loaded / progress.total) * 100);
                        updateStatus(`⏳ 載入進度: ${percent}%`, 'info');
                    }
                },
                function(error) {
                    console.error('FBX載入錯誤:', error);
                    updateStatus(`❌ 載入失敗: ${error.message || error}`, 'error');
                }
            );
        }

        function createTestCube() {
            updateStatus('🔨 創建測試立方體...', 'info');
            
            if (currentModel) {
                scene.remove(currentModel);
            }
            
            const geometry = new THREE.BoxGeometry(3, 3, 3);
            const material = new THREE.MeshLambertMaterial({ 
                color: 0x00ff88,
                transparent: true,
                opacity: 0.8
            });
            
            currentModel = new THREE.Mesh(geometry, material);
            currentModel.position.set(0, 1.5, 0);
            currentModel.castShadow = true;
            currentModel.receiveShadow = true;
            
            scene.add(currentModel);
            
            updateModelInfo('✅ 測試立方體 - 確認3D引擎正常工作');
            updateStatus('✅ 測試立方體已創建', 'success');
        }

        function resetCamera() {
            camera.position.set(8, 6, 8);
            camera.lookAt(0, 0, 0);
            controls.reset();
            updateStatus('🔄 視角已重置', 'info');
        }

        function toggleWireframe() {
            isWireframe = !isWireframe;
            
            if (currentModel) {
                currentModel.traverse(function(child) {
                    if (child.isMesh && child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => mat.wireframe = isWireframe);
                        } else {
                            child.material.wireframe = isWireframe;
                        }
                    }
                });
                
                updateStatus(isWireframe ? '📐 線框模式開啟' : '🎨 實體模式開啟', 'info');
            }
        }

        function downloadModel() {
            if (!currentModel) {
                updateStatus('❌ 沒有可下載的模型', 'error');
                return;
            }
            
            // 導出模型信息為JSON
            const modelData = {
                name: 'fuck.fbx',
                timestamp: new Date().toISOString(),
                boundingBox: {
                    min: new THREE.Box3().setFromObject(currentModel).min,
                    max: new THREE.Box3().setFromObject(currentModel).max,
                    size: new THREE.Box3().setFromObject(currentModel).getSize(new THREE.Vector3())
                },
                position: currentModel.position,
                rotation: currentModel.rotation,
                scale: currentModel.scale
            };
            
            const dataStr = JSON.stringify(modelData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = 'model-info.json';
            link.click();
            
            updateStatus('💾 模型數據已下載', 'success');
        }

        // 響應式處理
        window.addEventListener('resize', function() {
            const container = document.getElementById('viewer');
            if (container.clientWidth > 0) {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
        });

        // 初始化
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
