<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>FBX é¡è‰²è³‡è¨Šæ·±åº¦æª¢æ¸¬</title>
    <style>
        body { 
            margin: 0; 
            padding: 20px; 
            background: #1a1a1a; 
            color: white;
            font-family: 'Courier New', monospace;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .section {
            background: #2a2a2a;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border-left: 4px solid #4a90e2;
        }
        .critical {
            border-left-color: #e74c3c;
        }
        .success {
            border-left-color: #2ecc71;
        }
        .warning {
            border-left-color: #f39c12;
        }
        #viewer {
            width: 800px;
            height: 600px;
            border: 2px solid #555;
            margin: 20px auto;
            background: #000;
        }
        .analysis {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 5px;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .color-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }
        .color-sample {
            height: 50px;
            border: 1px solid #666;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.8);
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .stat-card {
            background: #333;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4a90e2;
        }
        button {
            background: #4a90e2;
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
        }
        button:hover {
            background: #357abd;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”¬ FBX é¡è‰²è³‡è¨Šæ·±åº¦æª¢æ¸¬å ±å‘Š</h1>
        
        <div class="section">
            <h2>æª¢æ¸¬ç›®çš„</h2>
            <p>é€™å€‹å·¥å…·æœƒæ·±åº¦åˆ†ææ‚¨çš„ FBX æª”æ¡ˆï¼Œç¢ºå®šï¼š</p>
            <ul>
                <li>æ¨¡å‹æ˜¯å¦åŒ…å«åŸå§‹é¡è‰²è³‡è¨Š</li>
                <li>é¡è‰²æ˜¯å¦åœ¨åŒ¯å‡ºéç¨‹ä¸­ä¸Ÿå¤±</li>
                <li>æè³ªé¡å‹å’Œå±¬æ€§</li>
                <li>å»ºè­°çš„ä¿®å¾©æ–¹æ¡ˆ</li>
            </ul>
            
            <div style="text-align: center; margin: 20px 0;">
                <button onclick="startDeepAnalysis()">é–‹å§‹æ·±åº¦æª¢æ¸¬</button>
                <button onclick="showRawData()">é¡¯ç¤ºåŸå§‹æ•¸æ“š</button>
                <button onclick="exportReport()">åŒ¯å‡ºå ±å‘Š</button>
            </div>
        </div>

        <div id="status-section" class="section">
            <h3>æª¢æ¸¬ç‹€æ…‹</h3>
            <div id="status">æº–å‚™é–‹å§‹æª¢æ¸¬...</div>
        </div>

        <div id="viewer"></div>

        <div id="results" style="display: none;">
            <div class="section success">
                <h2>ğŸ“Š æª¢æ¸¬çµæœç¸½è¦½</h2>
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-value" id="mesh-count">0</div>
                        <div>ç¶²æ ¼æ•¸é‡</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="material-count">0</div>
                        <div>æè³ªæ•¸é‡</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="color-count">0</div>
                        <div>æœ‰é¡è‰²æè³ª</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="texture-count">0</div>
                        <div>è²¼åœ–æ•¸é‡</div>
                    </div>
                </div>
            </div>

            <div id="color-analysis" class="section">
                <h2>ğŸ¨ é¡è‰²åˆ†æ</h2>
                <div id="color-grid" class="color-grid"></div>
            </div>

            <div id="conclusion-section" class="section">
                <h2>ğŸ¯ çµè«–å’Œå»ºè­°</h2>
                <div id="conclusion"></div>
            </div>

            <div class="section">
                <h2>ğŸ“‹ è©³ç´°åˆ†æå ±å‘Š</h2>
                <div id="detailed-analysis" class="analysis"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/fflate.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>

    <script>
        let scene, camera, renderer;
        let model;
        let analysisData = {};

        function updateStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.innerHTML = `<strong>[${new Date().toLocaleTimeString()}]</strong> ${message}`;
            console.log(message);
        }

        function log(message) {
            const analysisDiv = document.getElementById('detailed-analysis');
            analysisDiv.textContent += `[${new Date().toLocaleTimeString()}] ${message}\n`;
            analysisDiv.scrollTop = analysisDiv.scrollHeight;
        }

        function initViewer() {
            const container = document.getElementById('viewer');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2a2a2a);
            
            camera = new THREE.PerspectiveCamera(75, 800/600, 0.1, 1000);
            camera.position.set(5, 5, 5);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(800, 600);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);
            
            // å®Œæ•´çš„å…‰ç…§è¨­ç½®ä¾†æª¢æ¸¬æ‰€æœ‰å¯èƒ½çš„é¡è‰²
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            
            animate();
        }

        function startDeepAnalysis() {
            updateStatus('åˆå§‹åŒ– 3D æª¢è¦–å™¨...');
            initViewer();
            
            updateStatus('é–‹å§‹è¼‰å…¥ FBX æª”æ¡ˆ...');
            loadAndAnalyze();
        }

        function loadAndAnalyze() {
            const loader = new THREE.FBXLoader();
            
            loader.load(
                'models/3D_sample.fbx',
                function(object) {
                    updateStatus('FBX è¼‰å…¥æˆåŠŸï¼Œé–‹å§‹æ·±åº¦åˆ†æ...');
                    model = object;
                    
                    // è¨­ç½®æ¨¡å‹é¡¯ç¤º
                    setupModel();
                    
                    // åŸ·è¡Œæ·±åº¦åˆ†æ
                    performDeepAnalysis();
                },
                function(progress) {
                    const percent = progress.total > 0 ? Math.round((progress.loaded / progress.total) * 100) : 0;
                    updateStatus(`è¼‰å…¥é€²åº¦: ${percent}%`);
                },
                function(error) {
                    updateStatus(`è¼‰å…¥å¤±æ•—: ${error}`, 'error');
                    log(`éŒ¯èª¤è©³æƒ…: ${error}`);
                }
            );
        }

        function setupModel() {
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            
            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = 3 / maxDim;
            model.scale.setScalar(scale);
            
            model.position.set(
                -center.x * scale,
                -center.y * scale,
                -center.z * scale
            );
            
            scene.add(model);
        }

        function performDeepAnalysis() {
            log('=== FBX æ·±åº¦é¡è‰²åˆ†æé–‹å§‹ ===');
            log(`æª”æ¡ˆ: models/3D_sample.fbx`);
            log(`åˆ†ææ™‚é–“: ${new Date()}`);
            log('');
            
            analysisData = {
                meshes: [],
                totalMeshes: 0,
                totalMaterials: 0,
                hasColorMaterials: 0,
                hasTextureMaterials: 0,
                materialTypes: {},
                colors: [],
                hasOriginalColors: false,
                exportLossDetected: false,
                recommendations: []
            };

            model.traverse(function(child) {
                if (child.isMesh) {
                    analysisData.totalMeshes++;
                    
                    const meshData = {
                        name: child.name || `Mesh_${analysisData.totalMeshes}`,
                        hasMaterial: false,
                        materialType: 'none',
                        hasColor: false,
                        hasTexture: false,
                        colorInfo: null,
                        rawMaterial: null
                    };

                    if (child.material) {
                        analysisData.totalMaterials++;
                        meshData.hasMaterial = true;
                        meshData.materialType = child.material.type;
                        meshData.rawMaterial = child.material;
                        
                        // çµ±è¨ˆæè³ªé¡å‹
                        if (!analysisData.materialTypes[child.material.type]) {
                            analysisData.materialTypes[child.material.type] = 0;
                        }
                        analysisData.materialTypes[child.material.type]++;
                        
                        // æª¢æŸ¥é¡è‰²
                        if (child.material.color) {
                            meshData.hasColor = true;
                            analysisData.hasColorMaterials++;
                            
                            const color = child.material.color;
                            const r = Math.round(color.r * 255);
                            const g = Math.round(color.g * 255);
                            const b = Math.round(color.b * 255);
                            
                            meshData.colorInfo = {
                                hex: '#' + color.getHexString(),
                                rgb: [r, g, b],
                                isBlue: color.b > 0.5 && color.b > color.r && color.b > color.g,
                                isBlack: r < 20 && g < 20 && b < 20,
                                brightness: (r + g + b) / 3
                            };
                            
                            analysisData.colors.push(meshData.colorInfo);
                            
                            // æª¢æ¸¬æ˜¯å¦æœ‰çœŸæ­£çš„é¡è‰²ï¼ˆéé»‘ç™½ï¼‰
                            if (meshData.colorInfo.brightness > 30 && !meshData.colorInfo.isBlack) {
                                analysisData.hasOriginalColors = true;
                            }
                        }
                        
                        // æª¢æŸ¥è²¼åœ–
                        if (child.material.map || child.material.diffuseMap || child.material.albedoMap) {
                            meshData.hasTexture = true;
                            analysisData.hasTextureMaterials++;
                        }
                        
                        log(`ç¶²æ ¼ ${analysisData.totalMeshes}: ${meshData.name}`);
                        log(`  æè³ªé¡å‹: ${meshData.materialType}`);
                        log(`  æœ‰é¡è‰²: ${meshData.hasColor ? 'æ˜¯' : 'å¦'}`);
                        if (meshData.hasColor) {
                            log(`  é¡è‰²å€¼: ${meshData.colorInfo.hex} RGB(${meshData.colorInfo.rgb.join(', ')})`);
                            log(`  äº®åº¦: ${Math.round(meshData.colorInfo.brightness)}/255`);
                        }
                        log(`  æœ‰è²¼åœ–: ${meshData.hasTexture ? 'æ˜¯' : 'å¦'}`);
                        log('  ---');
                    } else {
                        log(`ç¶²æ ¼ ${analysisData.totalMeshes}: ${meshData.name} - ç„¡æè³ª`);
                        log('  ---');
                    }
                    
                    analysisData.meshes.push(meshData);
                }
            });

            // åˆ†æçµæœ
            analyzeResults();
            updateUI();
        }

        function analyzeResults() {
            log('');
            log('=== åˆ†æçµæœ ===');
            
            // æª¢æ¸¬é¡è‰²ä¸Ÿå¤±
            const coloredMeshes = analysisData.meshes.filter(m => m.hasColor);
            const brightColoredMeshes = coloredMeshes.filter(m => m.colorInfo.brightness > 50);
            
            log(`ç¸½ç¶²æ ¼æ•¸: ${analysisData.totalMeshes}`);
            log(`æœ‰æè³ªçš„ç¶²æ ¼: ${analysisData.totalMaterials}`);
            log(`æœ‰é¡è‰²çš„æè³ª: ${analysisData.hasColorMaterials}`);
            log(`æœ‰è²¼åœ–çš„æè³ª: ${analysisData.hasTextureMaterials}`);
            log(`æœ‰æ˜äº®é¡è‰²çš„æè³ª: ${brightColoredMeshes.length}`);
            
            // æè³ªé¡å‹åˆ†æ
            log('');
            log('æè³ªé¡å‹åˆ†ä½ˆ:');
            Object.entries(analysisData.materialTypes).forEach(([type, count]) => {
                log(`  ${type}: ${count} å€‹`);
            });
            
            // åˆ¤æ–·é¡è‰²ç‹€æ³
            log('');
            log('=== é¡è‰²ç‹€æ³è¨ºæ–· ===');
            
            if (analysisData.hasColorMaterials === 0) {
                log('âŒ æœªç™¼ç¾ä»»ä½•é¡è‰²è³‡è¨Š');
                analysisData.exportLossDetected = true;
                analysisData.recommendations.push('æ¨¡å‹åœ¨åŒ¯å‡ºéç¨‹ä¸­å®Œå…¨ä¸Ÿå¤±äº†é¡è‰²è³‡è¨Š');
                analysisData.recommendations.push('å»ºè­°æª¢æŸ¥åŸå§‹æª”æ¡ˆçš„åŒ¯å‡ºè¨­å®š');
                analysisData.recommendations.push('å¯èƒ½éœ€è¦é‡æ–°åŒ¯å‡º FBX æª”æ¡ˆ');
            } else if (brightColoredMeshes.length === 0) {
                log('âš ï¸ æœ‰é¡è‰²å±¬æ€§ä½†éƒ½å¤ªæš—æˆ–ç‚ºé»‘è‰²');
                analysisData.exportLossDetected = true;
                analysisData.recommendations.push('é¡è‰²è³‡è¨Šéƒ¨åˆ†ä¸Ÿå¤±ï¼Œåªå‰©ä¸‹æš—è‰²/é»‘è‰²');
                analysisData.recommendations.push('å»ºè­°åœ¨ç¨‹å¼ä¸­æ‰‹å‹•èª¿æ•´é¡è‰²');
            } else {
                log('âœ… ç™¼ç¾æœ‰æ•ˆçš„é¡è‰²è³‡è¨Š');
                analysisData.hasOriginalColors = true;
                
                // æª¢æŸ¥è—è‰²
                const blueMeshes = coloredMeshes.filter(m => m.colorInfo.isBlue);
                if (blueMeshes.length > 0) {
                    log(`âœ… ç™¼ç¾ ${blueMeshes.length} å€‹è—è‰²æè³ªï¼Œç¬¦åˆæ¨¡å‹å¸«æè¿°`);
                    analysisData.recommendations.push('æ¨¡å‹ç¢ºå¯¦åŒ…å«è—è‰²ï¼Œå¯ä»¥æ­£å¸¸é¡¯ç¤º');
                } else {
                    log('âš ï¸ æœªç™¼ç¾æ˜é¡¯çš„è—è‰²æè³ª');
                    analysisData.recommendations.push('å¯èƒ½éœ€è¦æ‰‹å‹•èª¿æ•´ç‚ºè—è‰²');
                }
            }
        }

        function updateUI() {
            document.getElementById('results').style.display = 'block';
            
            // æ›´æ–°çµ±è¨ˆ
            document.getElementById('mesh-count').textContent = analysisData.totalMeshes;
            document.getElementById('material-count').textContent = analysisData.totalMaterials;
            document.getElementById('color-count').textContent = analysisData.hasColorMaterials;
            document.getElementById('texture-count').textContent = analysisData.hasTextureMaterials;
            
            // æ›´æ–°é¡è‰²ç¶²æ ¼
            const colorGrid = document.getElementById('color-grid');
            colorGrid.innerHTML = '';
            
            if (analysisData.colors.length > 0) {
                analysisData.colors.forEach((colorInfo, index) => {
                    const colorDiv = document.createElement('div');
                    colorDiv.className = 'color-sample';
                    colorDiv.style.backgroundColor = colorInfo.hex;
                    colorDiv.style.color = colorInfo.brightness > 128 ? '#000' : '#fff';
                    colorDiv.textContent = colorInfo.hex;
                    colorGrid.appendChild(colorDiv);
                });
            } else {
                colorGrid.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #999;">æœªç™¼ç¾ä»»ä½•é¡è‰²</div>';
            }
            
            // æ›´æ–°çµè«–
            const conclusion = document.getElementById('conclusion');
            let conclusionHTML = '';
            
            if (analysisData.hasOriginalColors) {
                conclusionHTML += '<div class="section success"><h3>âœ… å¥½æ¶ˆæ¯ï¼</h3><p>æ‚¨çš„ FBX æª”æ¡ˆ<strong>ç¢ºå¯¦åŒ…å«é¡è‰²è³‡è¨Š</strong>ï¼Œæ²’æœ‰åœ¨åŒ¯å‡ºéç¨‹ä¸­å®Œå…¨ä¸Ÿå¤±ã€‚</p></div>';
            } else if (analysisData.exportLossDetected) {
                conclusionHTML += '<div class="section critical"><h3>âŒ ç™¼ç¾å•é¡Œ</h3><p>æ‚¨çš„ FBX æª”æ¡ˆ<strong>ç¼ºå°‘æœ‰æ•ˆçš„é¡è‰²è³‡è¨Š</strong>ï¼Œå¯èƒ½åœ¨åŒ¯å‡ºéç¨‹ä¸­ä¸Ÿå¤±äº†ã€‚</p></div>';
            }
            
            conclusionHTML += '<div class="section"><h3>ğŸ”§ å»ºè­°æªæ–½</h3><ul>';
            analysisData.recommendations.forEach(rec => {
                conclusionHTML += `<li>${rec}</li>`;
            });
            conclusionHTML += '</ul></div>';
            
            conclusion.innerHTML = conclusionHTML;
            
            updateStatus('æ·±åº¦åˆ†æå®Œæˆï¼æŸ¥çœ‹ä¸‹æ–¹çµæœã€‚');
        }

        function showRawData() {
            console.log('FBX Analysis Data:', analysisData);
            alert('åŸå§‹æ•¸æ“šå·²è¼¸å‡ºåˆ°ç€è¦½å™¨æ§åˆ¶å° (F12)');
        }

        function exportReport() {
            const report = {
                timestamp: new Date().toISOString(),
                file: 'models/3D_sample.fbx',
                summary: {
                    totalMeshes: analysisData.totalMeshes,
                    totalMaterials: analysisData.totalMaterials,
                    hasColorMaterials: analysisData.hasColorMaterials,
                    hasTextureMaterials: analysisData.hasTextureMaterials,
                    hasOriginalColors: analysisData.hasOriginalColors,
                    exportLossDetected: analysisData.exportLossDetected
                },
                materialTypes: analysisData.materialTypes,
                colors: analysisData.colors,
                recommendations: analysisData.recommendations
            };
            
            const dataStr = JSON.stringify(report, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = 'fbx-color-analysis-report.json';
            link.click();
            
            URL.revokeObjectURL(url);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (model) {
                model.rotation.y += 0.005;
            }
            
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
    </script>
</body>
</html>
