<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBX 模型測試 - 最終版本</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
        }
        #container {
            width: 800px;
            height: 600px;
            border: 2px solid #333;
            margin: 20px auto;
            background: #000;
        }
        .controls {
            text-align: center;
            margin: 20px;
        }
        .info {
            background: #333;
            padding: 15px;
            margin: 10px;
            border-radius: 5px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover {
            background: #357abd;
        }
        #debug {
            background: #2a2a2a;
            padding: 10px;
            margin: 10px;
            border-radius: 5px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h1>FBX 模型載入測試 - 完整版</h1>
    
    <div class="info">
        <h3>測試資訊</h3>
        <p>模型路徑: models/fuck.fbx</p>
        <p>Three.js 版本: r158</p>
        <p>測試重點: FBX 載入、材質顯示、顏色修復</p>
    </div>

    <div class="controls">
        <button onclick="loadFBXModel()">載入 FBX 模型</button>
        <button onclick="toggleAutoRotate()">切換自動旋轉</button>
        <button onclick="resetCamera()">重置視角</button>
        <button onclick="toggleWireframe()">線框模式</button>
        <button onclick="clearDebug()">清除記錄</button>
    </div>

    <div id="container"></div>

    <div class="info">
        <h3>模型資訊</h3>
        <div id="model-info">等待載入模型...</div>
    </div>

    <div class="info">
        <h3>除錯記錄</h3>
        <div id="debug"></div>
    </div>

    <!-- Three.js 庫 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/libs/fflate.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let currentModel = null;
        let autoRotate = true;

        function debugLog(message) {
            const debugDiv = document.getElementById('debug');
            const time = new Date().toLocaleTimeString();
            debugDiv.innerHTML += `[${time}] ${message}<br>`;
            debugDiv.scrollTop = debugDiv.scrollHeight;
            console.log(message);
        }

        function clearDebug() {
            document.getElementById('debug').innerHTML = '';
        }

        function updateModelInfo(info) {
            document.getElementById('model-info').innerHTML = info;
        }

        // 初始化 3D 場景
        function init() {
            const container = document.getElementById('container');
            
            // 場景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2a2a2a);
            
            // 相機
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);
            
            // 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(renderer.domElement);
            
            // 控制器
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = autoRotate;
            controls.autoRotateSpeed = 2;
            
            // 環境光
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // 方向光
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // 點光源
            const pointLight = new THREE.PointLight(0xffffff, 0.5, 100);
            pointLight.position.set(-10, 10, 10);
            scene.add(pointLight);
            
            // 地面
            const groundGeometry = new THREE.PlaneGeometry(20, 20);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x404040 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            debugLog('3D 場景初始化完成');
            
            // 檢查 FBXLoader 是否可用
            if (typeof THREE.FBXLoader !== 'undefined') {
                debugLog('✓ FBXLoader 已載入');
            } else {
                debugLog('✗ FBXLoader 未找到');
            }
            
            // 開始渲染循環
            animate();
        }

        function loadFBXModel() {
            if (typeof THREE.FBXLoader === 'undefined') {
                debugLog('錯誤: FBXLoader 未載入');
                return;
            }
            
            const loader = new THREE.FBXLoader();
            debugLog('開始載入 FBX 模型: models/fuck.fbx');
            
            loader.load(
                'models/fuck.fbx',
                function(object) {
                    debugLog('✓ FBX 模型載入成功');
                    
                    // 移除舊模型
                    if (currentModel) {
                        scene.remove(currentModel);
                        debugLog('移除了舊模型');
                    }
                    
                    currentModel = object;
                    
                    // 計算邊界盒和縮放
                    const box = new THREE.Box3().setFromObject(currentModel);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    
                    debugLog(`模型尺寸: ${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}`);
                    
                    // 縮放模型
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 3 / maxDim;
                    currentModel.scale.setScalar(scale);
                    debugLog(`縮放比例: ${scale.toFixed(3)}`);
                    
                    // 置中模型
                    currentModel.position.copy(center).multiplyScalar(-scale);
                    
                    // 分析和修復材質
                    let meshCount = 0;
                    let materialCount = 0;
                    let fixedMaterials = 0;
                    
                    currentModel.traverse(function(child) {
                        if (child.isMesh) {
                            meshCount++;
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            // 檢查和修復材質
                            if (!child.material) {
                                child.material = new THREE.MeshLambertMaterial({
                                    color: 0x4a90e2,
                                    transparent: false
                                });
                                fixedMaterials++;
                                debugLog(`添加默認材質: ${child.name || '未命名'}`);
                            } else {
                                materialCount++;
                                
                                if (child.material.type === 'MeshBasicMaterial') {
                                    const oldColor = child.material.color ? child.material.color.clone() : new THREE.Color(0x888888);
                                    child.material = new THREE.MeshLambertMaterial({
                                        color: oldColor,
                                        transparent: child.material.transparent || false,
                                        opacity: child.material.opacity || 1.0
                                    });
                                    fixedMaterials++;
                                    debugLog(`轉換 Basic→Lambert: ${child.name || '未命名'}`);
                                } else if (child.material.color) {
                                    const color = child.material.color;
                                    if (color.r < 0.1 && color.g < 0.1 && color.b < 0.1) {
                                        color.setHex(0x7289da);
                                        fixedMaterials++;
                                        debugLog(`調亮暗色材質: ${child.name || '未命名'}`);
                                    }
                                }
                                
                                debugLog(`材質: ${child.material.type}, 顏色: #${child.material.color.getHexString()}`);
                            }
                        }
                    });
                    
                    scene.add(currentModel);
                    
                    // 更新模型資訊
                    updateModelInfo(`
                        <strong>載入成功!</strong><br>
                        網格數量: ${meshCount}<br>
                        材質數量: ${materialCount}<br>
                        修復材質: ${fixedMaterials}<br>
                        模型尺寸: ${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}<br>
                        縮放比例: ${scale.toFixed(3)}
                    `);
                    
                    debugLog(`✓ 模型已添加到場景 (${meshCount} 個網格, ${materialCount} 個材質, ${fixedMaterials} 個修復)`);
                },
                function(progress) {
                    const percent = (progress.loaded / progress.total * 100).toFixed(1);
                    debugLog(`載入進度: ${percent}%`);
                },
                function(error) {
                    debugLog(`✗ 載入失敗: ${error}`);
                    updateModelInfo('<span style="color: red;">載入失敗</span>');
                }
            );
        }

        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            controls.autoRotate = autoRotate;
            debugLog(`自動旋轉: ${autoRotate ? '開啟' : '關閉'}`);
        }

        function resetCamera() {
            camera.position.set(5, 5, 5);
            controls.reset();
            debugLog('相機位置已重置');
        }

        function toggleWireframe() {
            if (currentModel) {
                currentModel.traverse(function(child) {
                    if (child.isMesh && child.material) {
                        child.material.wireframe = !child.material.wireframe;
                    }
                });
                debugLog('切換線框模式');
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (controls) {
                controls.update();
            }
            
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // 視窗大小調整
        window.addEventListener('resize', function() {
            const container = document.getElementById('container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

        // 頁面載入完成後初始化
        document.addEventListener('DOMContentLoaded', function() {
            debugLog('頁面載入完成，初始化 3D 場景...');
            init();
        });
    </script>
</body>
</html>
